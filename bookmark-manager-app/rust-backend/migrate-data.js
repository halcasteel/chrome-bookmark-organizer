#!/usr/bin/env node

/**
 * Data Migration Script - Migrate existing data from Node.js to Rust backend
 * This script doesn't actually move data, but configures the Rust services
 * to use the same database as the Node.js application.
 */

const { Pool } = require('pg');
const fs = require('fs').promises;
const path = require('path');

// Database configuration - same as used by both Node.js and Rust
const dbConfig = {
  host: 'localhost',
  port: 5434,
  user: 'admin',
  password: 'admin',
  database: 'bookmark_manager'
};

async function checkDatabaseConnection() {
  const pool = new Pool(dbConfig);
  
  try {
    const result = await pool.query('SELECT version()');
    console.log('‚úÖ Database connection successful');
    console.log('   PostgreSQL version:', result.rows[0].version);
    return pool;
  } catch (error) {
    console.error('‚ùå Database connection failed:', error.message);
    process.exit(1);
  }
}

async function analyzeTables(pool) {
  console.log('\nüìä Analyzing database tables...');
  
  const tablesQuery = `
    SELECT 
      table_name,
      (SELECT COUNT(*) FROM information_schema.columns WHERE table_name = t.table_name) as column_count
    FROM information_schema.tables t
    WHERE table_schema = 'public' 
    AND table_type = 'BASE TABLE'
    ORDER BY table_name;
  `;
  
  const tables = await pool.query(tablesQuery);
  
  console.log('\nTables found:');
  for (const table of tables.rows) {
    // Get row count for each table
    const countResult = await pool.query(`SELECT COUNT(*) as count FROM ${table.table_name}`);
    const rowCount = countResult.rows[0].count;
    
    console.log(`  - ${table.table_name}: ${rowCount} rows, ${table.column_count} columns`);
  }
  
  return tables.rows;
}

async function checkDataIntegrity(pool) {
  console.log('\nüîç Checking data integrity...');
  
  const checks = [
    {
      name: 'Users with bookmarks',
      query: `
        SELECT COUNT(DISTINCT u.id) as count
        FROM users u
        JOIN bookmarks b ON u.id = b.user_id
      `
    },
    {
      name: 'Bookmarks with tags',
      query: `
        SELECT COUNT(DISTINCT b.id) as count
        FROM bookmarks b
        JOIN bookmark_tags bt ON b.id = bt.bookmark_id
      `
    },
    {
      name: 'Bookmarks with embeddings',
      query: `
        SELECT COUNT(*) as count
        FROM bookmark_embeddings
      `
    },
    {
      name: 'Import history records',
      query: `
        SELECT COUNT(*) as count
        FROM import_history
      `
    },
    {
      name: 'A2A tasks',
      query: `
        SELECT COUNT(*) as count
        FROM a2a_tasks
      `
    }
  ];
  
  for (const check of checks) {
    try {
      const result = await pool.query(check.query);
      console.log(`  ‚úì ${check.name}: ${result.rows[0].count}`);
    } catch (error) {
      console.log(`  ‚úó ${check.name}: Error - ${error.message}`);
    }
  }
}

async function generateMigrationReport(pool, tables) {
  console.log('\nüìù Generating migration report...');
  
  const report = {
    timestamp: new Date().toISOString(),
    database: dbConfig.database,
    tables: {},
    summary: {
      totalTables: tables.length,
      totalRows: 0,
      readyForMigration: true
    }
  };
  
  for (const table of tables) {
    const countResult = await pool.query(`SELECT COUNT(*) as count FROM ${table.table_name}`);
    const rowCount = parseInt(countResult.rows[0].count);
    
    report.tables[table.table_name] = {
      rowCount,
      columns: table.column_count
    };
    
    report.summary.totalRows += rowCount;
  }
  
  // Write report to file
  const reportPath = path.join(__dirname, 'migration-report.json');
  await fs.writeFile(reportPath, JSON.stringify(report, null, 2));
  
  console.log(`\n‚úÖ Migration report saved to: ${reportPath}`);
  
  return report;
}

async function createRustEnvFile() {
  console.log('\nüîß Creating Rust .env file...');
  
  const envContent = `# Rust Services Configuration
# Generated by migrate-data.js

# Database (same as Node.js)
BOOKMARKS_DATABASE_URL=postgres://admin:admin@localhost:5434/bookmark_manager

# Server Configuration
BOOKMARKS_SERVER_HOST=0.0.0.0
BOOKMARKS_SERVER_PORT=8001  # Auth service
# BOOKMARKS_SERVER_PORT=8002  # Bookmarks service
# BOOKMARKS_SERVER_PORT=8003  # Import service
# BOOKMARKS_SERVER_PORT=8004  # Search service

# Redis (same as Node.js)
BOOKMARKS_REDIS_URL=redis://localhost:6382

# JWT Secret (must match Node.js for compatibility)
BOOKMARKS_JWT_SECRET=${process.env.JWT_SECRET || 'test-secret-key-change-in-production'}

# Optional: OpenAI API Key for embeddings
# BOOKMARKS_OPENAI_API_KEY=your-api-key-here

# Logging
RUST_LOG=info,sqlx=warn
`;
  
  const envPath = path.join(__dirname, '.env');
  await fs.writeFile(envPath, envContent);
  
  console.log(`‚úÖ Rust .env file created at: ${envPath}`);
}

async function main() {
  console.log('üöÄ Starting data migration analysis for Rust services...');
  console.log('=' .repeat(60));
  
  // Check database connection
  const pool = await checkDatabaseConnection();
  
  try {
    // Analyze tables
    const tables = await analyzeTables(pool);
    
    // Check data integrity
    await checkDataIntegrity(pool);
    
    // Generate migration report
    const report = await generateMigrationReport(pool, tables);
    
    // Create Rust env file
    await createRustEnvFile();
    
    console.log('\n' + '='.repeat(60));
    console.log('üìä Migration Summary:');
    console.log('='.repeat(60));
    console.log(`Total tables: ${report.summary.totalTables}`);
    console.log(`Total rows: ${report.summary.totalRows.toLocaleString()}`);
    console.log('\n‚úÖ Database is ready for Rust services!');
    console.log('\nNext steps:');
    console.log('1. Start Rust services using the same database');
    console.log('2. Update frontend to use Rust API endpoints');
    console.log('3. Gradually transition from Node.js to Rust');
    console.log('\nNo data migration needed - both systems use the same database! üéâ');
    
  } catch (error) {
    console.error('\n‚ùå Migration analysis failed:', error);
    process.exit(1);
  } finally {
    await pool.end();
  }
}

// Run the migration
main().catch(console.error);